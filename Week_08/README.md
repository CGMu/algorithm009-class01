# å­¦ä¹ ç¬”è®°    

å¯¹äºwebå¼€å‘è€Œè¨€ï¼Œç¼“å­˜å¿…ä¸å¯å°‘ï¼Œä¹Ÿæ˜¯æé«˜æ€§èƒ½æœ€å¸¸ç”¨çš„æ–¹å¼ã€‚æ— è®ºæ˜¯æµè§ˆå™¨ç¼“å­˜(å¦‚æœæ˜¯chromeæµè§ˆå™¨ï¼Œå¯ä»¥é€šè¿‡chrome:ğŸ˜•/cacheæŸ¥çœ‹)ï¼Œè¿˜æ˜¯æœåŠ¡ç«¯çš„ç¼“å­˜(é€šè¿‡memcachedæˆ–è€…redisç­‰å†…å­˜æ•°æ®åº“)ã€‚ç¼“å­˜ä¸ä»…å¯ä»¥åŠ é€Ÿç”¨æˆ·çš„è®¿é—®ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥é™ä½æœåŠ¡å™¨çš„è´Ÿè½½å’Œå‹åŠ›ã€‚é‚£ä¹ˆï¼Œäº†è§£å¸¸è§çš„ç¼“å­˜æ·˜æ±°ç®—æ³•çš„ç­–ç•¥å’ŒåŸç†å°±æ˜¾å¾—ç‰¹åˆ«é‡è¦ã€‚    

## 1. å¸¸è§çš„ç¼“å­˜ç®—æ³•    
**LRU (Least recently used) æœ€è¿‘æœ€å°‘ä½¿ç”¨**ï¼Œå¦‚æœæ•°æ®æœ€è¿‘è¢«è®¿é—®è¿‡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„å‡ ç‡ä¹Ÿæ›´é«˜ã€‚
**LFU (Least frequently used) æœ€ä¸ç»å¸¸ä½¿ç”¨**ï¼Œå¦‚æœä¸€ä¸ªæ•°æ®åœ¨æœ€è¿‘ä¸€æ®µæ—¶é—´å†…ä½¿ç”¨æ¬¡æ•°å¾ˆå°‘ï¼Œé‚£ä¹ˆåœ¨å°†æ¥ä¸€æ®µæ—¶é—´å†…è¢«ä½¿ç”¨çš„å¯èƒ½æ€§ä¹Ÿå¾ˆå°ã€‚
**FIFO (Fist in first out) å…ˆè¿›å…ˆå‡º**ï¼Œ å¦‚æœä¸€ä¸ªæ•°æ®æœ€å…ˆè¿›å…¥ç¼“å­˜ä¸­ï¼Œåˆ™åº”è¯¥æœ€æ—©æ·˜æ±°æ‰ã€‚

## 2. LRUç¼“å­˜    
åƒæµè§ˆå™¨çš„ç¼“å­˜ç­–ç•¥ã€memcachedçš„ç¼“å­˜ç­–ç•¥éƒ½æ˜¯ä½¿ç”¨LRUè¿™ä¸ªç®—æ³•ï¼ŒLRUç®—æ³•ä¼šå°†è¿‘æœŸæœ€ä¸ä¼šè®¿é—®çš„æ•°æ®æ·˜æ±°æ‰ã€‚LRUå¦‚æ­¤æµè¡Œçš„åŸå› æ˜¯å®ç°æ¯”è¾ƒç®€å•ï¼Œè€Œä¸”å¯¹äºå®é™…é—®é¢˜ä¹Ÿå¾ˆå®ç”¨ï¼Œè‰¯å¥½çš„è¿è¡Œæ—¶æ€§èƒ½ï¼Œå‘½ä¸­ç‡è¾ƒé«˜ã€‚ä¸‹é¢è°ˆè°ˆå¦‚ä½•å®ç°LRUç¼“å­˜ï¼š   


æ–°æ•°æ®æ’å…¥åˆ°é“¾è¡¨å¤´éƒ¨
æ¯å½“ç¼“å­˜å‘½ä¸­ï¼ˆå³ç¼“å­˜æ•°æ®è¢«è®¿é—®ï¼‰ï¼Œåˆ™å°†æ•°æ®ç§»åˆ°é“¾è¡¨å¤´éƒ¨
å½“é“¾è¡¨æ»¡çš„æ—¶å€™ï¼Œå°†é“¾è¡¨å°¾éƒ¨çš„æ•°æ®ä¸¢å¼ƒ
LRU Cacheå…·å¤‡çš„æ“ä½œï¼š

set(key,value)ï¼šå¦‚æœkeyåœ¨hashmapä¸­å­˜åœ¨ï¼Œåˆ™å…ˆé‡ç½®å¯¹åº”çš„valueå€¼ï¼Œç„¶åè·å–å¯¹åº”çš„èŠ‚ç‚¹curï¼Œå°†curèŠ‚ç‚¹ä»é“¾è¡¨åˆ é™¤ï¼Œå¹¶ç§»åŠ¨åˆ°é“¾è¡¨çš„å¤´éƒ¨ï¼›è‹¥æœkeyåœ¨hashmapä¸å­˜åœ¨ï¼Œåˆ™æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶å°†èŠ‚ç‚¹æ”¾åˆ°é“¾è¡¨çš„å¤´éƒ¨ã€‚å½“Cacheå­˜æ»¡çš„æ—¶å€™ï¼Œå°†é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹åˆ é™¤å³å¯ã€‚
get(key)ï¼šå¦‚æœkeyåœ¨hashmapä¸­å­˜åœ¨ï¼Œåˆ™æŠŠå¯¹åº”çš„èŠ‚ç‚¹æ”¾åˆ°é“¾è¡¨å¤´éƒ¨ï¼Œå¹¶è¿”å›å¯¹åº”çš„valueå€¼ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å›-1ã€‚
LRUçš„c++å®ç°
LRUå®ç°é‡‡ç”¨åŒå‘é“¾è¡¨ + Map æ¥è¿›è¡Œå®ç°ã€‚è¿™é‡Œé‡‡ç”¨åŒå‘é“¾è¡¨çš„åŸå› æ˜¯ï¼šå¦‚æœé‡‡ç”¨æ™®é€šçš„å•é“¾è¡¨ï¼Œåˆ™åˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™éœ€è¦ä»è¡¨å¤´å¼€å§‹éå†æŸ¥æ‰¾ï¼Œæ•ˆç‡ä¸ºO(n)ï¼Œé‡‡ç”¨åŒå‘é“¾è¡¨å¯ä»¥ç›´æ¥æ”¹å˜èŠ‚ç‚¹çš„å‰é©±çš„æŒ‡é’ˆæŒ‡å‘è¿›è¡Œåˆ é™¤è¾¾åˆ°O(1)çš„æ•ˆç‡ã€‚ä½¿ç”¨Mapæ¥ä¿å­˜èŠ‚ç‚¹çš„keyã€valueå€¼ä¾¿äºèƒ½åœ¨O(logN)çš„æ—¶é—´æŸ¥æ‰¾å…ƒç´ ,å¯¹åº”getæ“ä½œã€‚

åŒé“¾è¡¨èŠ‚ç‚¹çš„å®šä¹‰ï¼š

struct CacheNode {
  int key;      // é”®
  int value;    // å€¼
  CacheNode *pre, *next;  // èŠ‚ç‚¹çš„å‰é©±ã€åç»§æŒ‡é’ˆ
  CacheNode(int k, int v) : key(k), value(v), pre(NULL), next(NULL) {}
};
å¯¹äºLRUCacheè¿™ä¸ªç±»è€Œè¨€ï¼Œæ„é€ å‡½æ•°éœ€è¦æŒ‡å®šå®¹é‡å¤§å°

LRUCache(int capacity)
{
  size = capacity;      // å®¹é‡
  head = NULL;          // é“¾è¡¨å¤´æŒ‡é’ˆ
  tail = NULL;          // é“¾è¡¨å°¾æŒ‡é’ˆ
}
åŒé“¾è¡¨çš„èŠ‚ç‚¹åˆ é™¤æ“ä½œï¼š

void remove(CacheNode *node)
{
  if (node -> pre != NULL)
  {
    node -> pre -> next = node -> next;
  }
  else
  {
    head = node -> next;
  }
  if (node -> next != NULL)
  {
    node -> next -> pre = node -> pre;
  }
  else
  {
    tail = node -> pre;
  }
}
å°†èŠ‚ç‚¹æ’å…¥åˆ°å¤´éƒ¨çš„æ“ä½œï¼š

void setHead(CacheNode *node)
{
  node -> next = head;
  node -> pre = NULL;

  if (head != NULL)
  {
    head -> pre = node;
  }
  head = node;
  if (tail == NULL)
  {
    tail = head;
  }
}
get(key)æ“ä½œçš„å®ç°æ¯”è¾ƒç®€å•ï¼Œç›´æ¥é€šè¿‡åˆ¤æ–­Mapæ˜¯å¦å«æœ‰keyå€¼å³å¯ï¼Œå¦‚æœæŸ¥æ‰¾åˆ°keyï¼Œåˆ™è¿”å›å¯¹åº”çš„valueï¼Œå¦åˆ™è¿”å›-1;

int get(int key)
{
  map<int, CacheNode *>::iterator it = mp.find(key);
  if (it != mp.end())
  {
    CacheNode *node = it -> second;
    remove(node);
    setHead(node);
    return node -> value;
  }
  else
  {
    return -1;
  }
}
set(key, value)æ“ä½œéœ€è¦åˆ†æƒ…å†µåˆ¤æ–­ã€‚å¦‚æœå½“å‰çš„keyå€¼å¯¹åº”çš„èŠ‚ç‚¹å·²ç»å­˜åœ¨ï¼Œåˆ™å°†è¿™ä¸ªèŠ‚ç‚¹å–å‡ºæ¥ï¼Œå¹¶ä¸”åˆ é™¤èŠ‚ç‚¹æ‰€å¤„çš„åŸæœ‰çš„ä½ç½®ï¼Œå¹¶åœ¨å¤´éƒ¨æ’å…¥è¯¥èŠ‚ç‚¹ï¼›å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨èŠ‚ç‚¹ä¸­ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åœ¨é“¾è¡¨çš„å¤´éƒ¨æ’å…¥æ–°èŠ‚ç‚¹ï¼Œæ’å…¥æ–°èŠ‚ç‚¹å¯èƒ½å¯¼è‡´å®¹é‡æº¢å‡ºï¼Œå¦‚æœå‡ºç°æº¢å‡ºçš„æƒ…å†µï¼Œåˆ™éœ€è¦åˆ é™¤é“¾è¡¨å°¾éƒ¨çš„èŠ‚ç‚¹ã€‚

void set(int key, int value)
{
  map<int, CacheNode *>::iterator it = mp.find(key);
  if (it != mp.end())
  {
    CacheNode *node = it -> second;
    node -> value = value;
    remove(node);
    setHead(node);
  }
  else
  {
    CacheNode *newNode = new CacheNode(key, value);
    if (mp.size() >= size)
    {
      map<int, CacheNode *>::iterator iter = mp.find(tail -> key);
      remove(tail);
      mp.erase(iter);
    }
    setHead(newNode);
    mp[key] = newNode;
  }
}
è‡³æ­¤ï¼ŒLRUç®—æ³•çš„å®ç°æ“ä½œå°±å®Œæˆäº†